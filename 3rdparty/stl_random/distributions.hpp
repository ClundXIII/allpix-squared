/**
 * @file
 * @brief Random distributions, copied from
 * @copyright Copyright (c) 2007-2018 Free Software Foundation, Inc.
 *
 * This file is part of the GNU ISO C++ Library.  This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3, or (at
 * your option) any later version.
 */

#ifndef ALLPIX_RANDOM_DISTRIBUTIONS_H
#define ALLPIX_RANDOM_DISTRIBUTIONS_H

namespace allpix {
    /*
     * Implementation-space details.
     */
    namespace __detail {
        template <typename _UIntType,
                  size_t __w,
                  bool = __w<static_cast<size_t>(std::numeric_limits<_UIntType>::digits)> struct _Shift {
            static const _UIntType __value = 0;
        };

        template <typename _UIntType, size_t __w> struct _Shift<_UIntType, __w, true> {
            static const _UIntType __value = _UIntType(1) << __w;
        };

        template <int __s,
                  int __which = ((__s <= __CHAR_BIT__ * sizeof(int)) + (__s <= __CHAR_BIT__ * sizeof(long)) +
                                 (__s <= __CHAR_BIT__ * sizeof(long long))
                                 /* assume long long no bigger than __int128 */
                                 +
                                 (__s <= 128))>
        struct _Select_uint_least_t {
            static_assert(__which < 0, /* needs to be dependent */
                          "sorry, would be too much trouble for a slow result");
        };

        template <int __s> struct _Select_uint_least_t<__s, 4> { typedef unsigned int type; };

        template <int __s> struct _Select_uint_least_t<__s, 3> { typedef unsigned long type; };

        template <int __s> struct _Select_uint_least_t<__s, 2> { typedef unsigned long long type; };

        // Assume a != 0, a < m, c < m, x < m.
        template <typename _Tp,
                  _Tp __m,
                  _Tp __a,
                  _Tp __c,
                  bool __big_enough = (!(__m & (__m - 1)) || (_Tp(-1) - __c) / __a >= __m - 1),
                  bool __schrage_ok = __m % __a<__m / __a> struct _Mod {
            typedef typename _Select_uint_least_t<std::__lg(__a) + std::__lg(__m) + 2>::type _Tp2;
            static _Tp __calc(_Tp __x) { return static_cast<_Tp>((_Tp2(__a) * __x + __c) % __m); }
        };

        // Schrage.
        template <typename _Tp, _Tp __m, _Tp __a, _Tp __c> struct _Mod<_Tp, __m, __a, __c, false, true> {
            static _Tp __calc(_Tp __x);
        };

        // Special cases:
        // - for m == 2^n or m == 0, unsigned integer overflow is safe.
        // - a * (m - 1) + c fits in _Tp, there is no overflow.
        template <typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool __s> struct _Mod<_Tp, __m, __a, __c, true, __s> {
            static _Tp __calc(_Tp __x) {
                _Tp __res = __a * __x + __c;
                if(__m)
                    __res %= __m;
                return __res;
            }
        };

        template <typename _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0> inline _Tp __mod(_Tp __x) {
            return _Mod<_Tp, __m, __a, __c>::__calc(__x);
        }

        /*
         * An adaptor class for converting the output of any Generator into
         * the input for a specific Distribution.
         */
        template <typename _Engine, typename _DInputType> struct _Adaptor {
            static_assert(std::is_floating_point<_DInputType>::value, "template argument must be a floating point type");

        public:
            _Adaptor(_Engine& __g) : _M_g(__g) {}

            _DInputType min() const { return _DInputType(0); }

            _DInputType max() const { return _DInputType(1); }

            /*
             * Converts a value generated by the adapted random number generator
             * into a value in the input domain for the dependent random number
             * distribution.
             */
            _DInputType operator()() {
                return std::generate_canonical<_DInputType, std::numeric_limits<_DInputType>::digits, _Engine>(_M_g);
            }

        private:
            _Engine& _M_g;
        };

    } // namespace __detail

    /**
    * @brief A normal continuous distribution for random numbers.
    *
    * The formula for the normal probability density function is
    * @f[
    *     p(x|\mu,\sigma) = \frac{1}{\sigma \sqrt{2 \pi}}
    *            e^{- \frac{{x - \mu}^ {2}}{2 \sigma ^ {2}} }
    * @f]
    */
    template <typename _RealType = double> class normal_distribution {
        static_assert(std::is_floating_point<_RealType>::value, "result_type must be a floating point type");

    public:
        /** The type of the range of the distribution. */
        typedef _RealType result_type;

        /** Parameter type. */
        struct param_type {
            typedef normal_distribution<_RealType> distribution_type;

            explicit param_type(_RealType __mean = _RealType(0), _RealType __stddev = _RealType(1))
                : _M_mean(__mean), _M_stddev(__stddev) {
                __glibcxx_assert(_M_stddev > _RealType(0));
            }

            _RealType mean() const { return _M_mean; }

            _RealType stddev() const { return _M_stddev; }

            friend bool operator==(const param_type& __p1, const param_type& __p2) {
                return (__p1._M_mean == __p2._M_mean && __p1._M_stddev == __p2._M_stddev);
            }

            friend bool operator!=(const param_type& __p1, const param_type& __p2) { return !(__p1 == __p2); }

        private:
            _RealType _M_mean;
            _RealType _M_stddev;
        };

    public:
        /**
        * Constructs a normal distribution with parameters @f$mean@f$ and
        * standard deviation.
        */
        explicit normal_distribution(result_type __mean = result_type(0), result_type __stddev = result_type(1))
            : _M_param(__mean, __stddev), _M_saved_available(false) {}

        explicit normal_distribution(const param_type& __p) : _M_param(__p), _M_saved_available(false) {}

        /**
        * @brief Resets the distribution state.
        */
        void reset() { _M_saved_available = false; }

        /**
        * @brief Returns the mean of the distribution.
        */
        _RealType mean() const { return _M_param.mean(); }

        /**
        * @brief Returns the standard deviation of the distribution.
        */
        _RealType stddev() const { return _M_param.stddev(); }

        /**
        * @brief Returns the parameter set of the distribution.
        */
        param_type param() const { return _M_param; }

        /**
        * @brief Sets the parameter set of the distribution.
        * @param __param The new parameter set of the distribution.
        */
        void param(const param_type& __param) { _M_param = __param; }

        /**
        * @brief Returns the greatest lower bound value of the distribution.
        */
        result_type min() const { return std::numeric_limits<result_type>::lowest(); }

        /**
        * @brief Returns the least upper bound value of the distribution.
        */
        result_type max() const { return std::numeric_limits<result_type>::max(); }

        /**
        * @brief Generating functions.
        */
        template <typename _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator& __urng) {
            return this->operator()(__urng, _M_param);
        }

        template <typename _UniformRandomNumberGenerator>
        result_type operator()(_UniformRandomNumberGenerator& __urng, const param_type& __p);

        template <typename _ForwardIterator, typename _UniformRandomNumberGenerator>
        void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator& __urng) {
            this->__generate(__f, __t, __urng, _M_param);
        }

        template <typename _ForwardIterator, typename _UniformRandomNumberGenerator>
        void __generate(_ForwardIterator __f,
                        _ForwardIterator __t,
                        _UniformRandomNumberGenerator& __urng,
                        const param_type& __p) {
            this->__generate_impl(__f, __t, __urng, __p);
        }

        template <typename _UniformRandomNumberGenerator>
        void __generate(result_type* __f, result_type* __t, _UniformRandomNumberGenerator& __urng, const param_type& __p) {
            this->__generate_impl(__f, __t, __urng, __p);
        }

        /**
        * @brief Return true if two normal distributions have
        *        the same parameters and the sequences that would
        *        be generated are equal.
        */
        template <typename _RealType1>
        friend bool operator==(const std::normal_distribution<_RealType1>& __d1,
                               const std::normal_distribution<_RealType1>& __d2);

        /**
        * @brief Inserts a %normal_distribution random number distribution
        * @p __x into the output stream @p __os.
        *
        * @param __os An output stream.
        * @param __x  A %normal_distribution random number distribution.
        *
        * @returns The output stream with the state of @p __x inserted or in
        * an error state.
        */
        template <typename _RealType1, typename _CharT, typename _Traits>
        friend std::basic_ostream<_CharT, _Traits>& operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                                                               const std::normal_distribution<_RealType1>& __x);

        /**
        * @brief Extracts a %normal_distribution random number distribution
        * @p __x from the input stream @p __is.
        *
        * @param __is An input stream.
        * @param __x  A %normal_distribution random number generator engine.
        *
        * @returns The input stream with @p __x extracted or in an error
        *          state.
        */
        template <typename _RealType1, typename _CharT, typename _Traits>
        friend std::basic_istream<_CharT, _Traits>& operator>>(std::basic_istream<_CharT, _Traits>& __is,
                                                               std::normal_distribution<_RealType1>& __x);

    private:
        template <typename _ForwardIterator, typename _UniformRandomNumberGenerator>
        void __generate_impl(_ForwardIterator __f,
                             _ForwardIterator __t,
                             _UniformRandomNumberGenerator& __urng,
                             const param_type& __p);

        param_type _M_param;
        result_type _M_saved;
        bool _M_saved_available;
    };

    /**
    * @brief Return true if two normal distributions are different.
    */
    template <typename _RealType>
    inline bool operator!=(const std::normal_distribution<_RealType>& __d1,
                           const std::normal_distribution<_RealType>& __d2) {
        return !(__d1 == __d2);
    }

    /**
     * Polar method due to Marsaglia.
     *
     * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
     * New York, 1986, Ch. V, Sect. 4.4.
     */
    template <typename _RealType>
    template <typename _UniformRandomNumberGenerator>
    typename normal_distribution<_RealType>::result_type normal_distribution<_RealType>::
    operator()(_UniformRandomNumberGenerator& __urng, const param_type& __param) {
        result_type __ret;
        __detail::_Adaptor<_UniformRandomNumberGenerator, result_type> __aurng(__urng);

        if(_M_saved_available) {
            _M_saved_available = false;
            __ret = _M_saved;
        } else {
            result_type __x, __y, __r2;
            do {
                __x = result_type(2.0) * __aurng() - 1.0;
                __y = result_type(2.0) * __aurng() - 1.0;
                __r2 = __x * __x + __y * __y;
            } while(__r2 > 1.0 || __r2 == 0.0);

            const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
            _M_saved = __x * __mult;
            _M_saved_available = true;
            __ret = __y * __mult;
        }

        __ret = __ret * __param.stddev() + __param.mean();
        return __ret;
    }

    template <typename _RealType>
    template <typename _ForwardIterator, typename _UniformRandomNumberGenerator>
    void normal_distribution<_RealType>::__generate_impl(_ForwardIterator __f,
                                                         _ForwardIterator __t,
                                                         _UniformRandomNumberGenerator& __urng,
                                                         const param_type& __param) {
        __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)

            if(__f == __t) return;

        if(_M_saved_available) {
            _M_saved_available = false;
            *__f++ = _M_saved * __param.stddev() + __param.mean();

            if(__f == __t)
                return;
        }

        __detail::_Adaptor<_UniformRandomNumberGenerator, result_type> __aurng(__urng);

        while(__f + 1 < __t) {
            result_type __x, __y, __r2;
            do {
                __x = result_type(2.0) * __aurng() - 1.0;
                __y = result_type(2.0) * __aurng() - 1.0;
                __r2 = __x * __x + __y * __y;
            } while(__r2 > 1.0 || __r2 == 0.0);

            const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
            *__f++ = __y * __mult * __param.stddev() + __param.mean();
            *__f++ = __x * __mult * __param.stddev() + __param.mean();
        }

        if(__f != __t) {
            result_type __x, __y, __r2;
            do {
                __x = result_type(2.0) * __aurng() - 1.0;
                __y = result_type(2.0) * __aurng() - 1.0;
                __r2 = __x * __x + __y * __y;
            } while(__r2 > 1.0 || __r2 == 0.0);

            const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
            _M_saved = __x * __mult;
            _M_saved_available = true;
            *__f = __y * __mult * __param.stddev() + __param.mean();
        }
    }

    template <typename _RealType>
    bool operator==(const std::normal_distribution<_RealType>& __d1, const std::normal_distribution<_RealType>& __d2) {
        if(__d1._M_param == __d2._M_param && __d1._M_saved_available == __d2._M_saved_available) {
            if(__d1._M_saved_available && __d1._M_saved == __d2._M_saved)
                return true;
            else if(!__d1._M_saved_available)
                return true;
            else
                return false;
        } else
            return false;
    }

    template <typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>& operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                                                    const normal_distribution<_RealType>& __x) {
        typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;

        const typename __ios_base::fmtflags __flags = __os.flags();
        const _CharT __fill = __os.fill();
        const std::streamsize __precision = __os.precision();
        const _CharT __space = __os.widen(' ');
        __os.flags(__ios_base::scientific | __ios_base::left);
        __os.fill(__space);
        __os.precision(std::numeric_limits<_RealType>::max_digits10);

        __os << __x.mean() << __space << __x.stddev() << __space << __x._M_saved_available;
        if(__x._M_saved_available)
            __os << __space << __x._M_saved;

        __os.flags(__flags);
        __os.fill(__fill);
        __os.precision(__precision);
        return __os;
    }

    template <typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>& operator>>(std::basic_istream<_CharT, _Traits>& __is,
                                                    normal_distribution<_RealType>& __x) {
        typedef std::basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::ios_base __ios_base;

        const typename __ios_base::fmtflags __flags = __is.flags();
        __is.flags(__ios_base::dec | __ios_base::skipws);

        double __mean, __stddev;
        __is >> __mean >> __stddev >> __x._M_saved_available;
        if(__x._M_saved_available)
            __is >> __x._M_saved;
        __x.param(typename normal_distribution<_RealType>::param_type(__mean, __stddev));

        __is.flags(__flags);
        return __is;
    }
}

#endif // ALLPIX_RANDOM_DISTRIBUTIONS_H
